{"version":3,"sources":["../src/cohere-provider.ts","../src/cohere-chat-language-model.ts","../src/cohere-error.ts","../src/convert-to-cohere-chat-prompt.ts","../src/map-cohere-finish-reason.ts","../src/cohere-embedding-model.ts"],"sourcesContent":["import {\n  EmbeddingModelV1,\n  LanguageModelV1,\n  ProviderV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  generateId,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { CohereChatLanguageModel } from './cohere-chat-language-model';\nimport { CohereChatModelId, CohereChatSettings } from './cohere-chat-settings';\nimport { CohereEmbeddingModel } from './cohere-embedding-model';\nimport {\n  CohereEmbeddingModelId,\n  CohereEmbeddingSettings,\n} from './cohere-embedding-settings';\n\nexport interface CohereProvider extends ProviderV1 {\n  (modelId: CohereChatModelId, settings?: CohereChatSettings): LanguageModelV1;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(\n    modelId: CohereChatModelId,\n    settings?: CohereChatSettings,\n  ): LanguageModelV1;\n\n  embedding(\n    modelId: CohereEmbeddingModelId,\n    settings?: CohereEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  textEmbeddingModel(\n    modelId: CohereEmbeddingModelId,\n    settings?: CohereEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n}\n\nexport interface CohereProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://api.cohere.com/v1`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being send using the `Authorization` header.\nIt defaults to the `COHERE_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  generateId?: () => string;\n}\n\n/**\nCreate a Cohere AI provider instance.\n */\nexport function createCohere(\n  options: CohereProviderSettings = {},\n): CohereProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.cohere.com/v1';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'COHERE_API_KEY',\n      description: 'Cohere',\n    })}`,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: CohereChatModelId,\n    settings: CohereChatSettings = {},\n  ) =>\n    new CohereChatLanguageModel(modelId, settings, {\n      provider: 'cohere.chat',\n      baseURL,\n      headers: getHeaders,\n      generateId: options.generateId ?? generateId,\n      fetch: options.fetch,\n    });\n\n  const createTextEmbeddingModel = (\n    modelId: CohereEmbeddingModelId,\n    settings: CohereEmbeddingSettings = {},\n  ) =>\n    new CohereEmbeddingModel(modelId, settings, {\n      provider: 'cohere.textEmbedding',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (\n    modelId: CohereChatModelId,\n    settings?: CohereChatSettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Cohere model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.embedding = createTextEmbeddingModel;\n  provider.textEmbeddingModel = createTextEmbeddingModel;\n\n  return provider as CohereProvider;\n}\n\n/**\nDefault Cohere provider instance.\n */\nexport const cohere = createCohere();\n","import {\n  LanguageModelV1,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createJsonResponseHandler,\n  createJsonStreamResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport {\n  CohereChatModelId,\n  CohereChatSettings,\n} from '../src/cohere-chat-settings';\nimport { cohereFailedResponseHandler } from '../src/cohere-error';\nimport { convertToCohereChatPrompt } from '../src/convert-to-cohere-chat-prompt';\nimport { mapCohereFinishReason } from '../src/map-cohere-finish-reason';\n\ntype CohereChatConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  generateId: () => string;\n  fetch?: FetchFunction;\n};\n\nexport class CohereChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: CohereChatModelId;\n  readonly settings: CohereChatSettings;\n\n  private readonly config: CohereChatConfig;\n\n  constructor(\n    modelId: CohereChatModelId,\n    settings: CohereChatSettings,\n    config: CohereChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const chatPrompt = convertToCohereChatPrompt(prompt);\n\n    // Cohere distinguishes between the current message and the chat history\n    const lastMessage = chatPrompt.at(-1);\n    const history = chatPrompt.slice(0, -1);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      // none\n\n      // standardized settings:\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      max_tokens: maxTokens,\n      temperature,\n      p: topP,\n      k: topK,\n      seed,\n      stop_sequences: stopSequences,\n\n      // response format:\n      response_format:\n        responseFormat?.type === 'json'\n          ? { type: 'json_object', schema: responseFormat.schema }\n          : undefined,\n\n      // messages:\n      chat_history: history,\n      ...(lastMessage?.role === 'TOOL'\n        ? { tool_results: lastMessage.tool_results }\n        : {}),\n      message: lastMessage\n        ? lastMessage.role === 'USER'\n          ? lastMessage.message\n          : undefined\n        : undefined,\n    };\n\n    switch (type) {\n      case 'regular': {\n        return { ...baseArgs, ...prepareToolsAndToolChoice(mode) };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const args = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { chat_history, message, ...rawSettings } = args;\n    const generateId = this.config.generateId;\n\n    return {\n      text: response.text,\n      toolCalls: response.tool_calls\n        ? response.tool_calls.map(toolCall => ({\n            toolCallId: generateId(),\n            toolName: toolCall.name,\n            args: JSON.stringify(toolCall.parameters),\n            toolCallType: 'function',\n          }))\n        : [],\n      finishReason: mapCohereFinishReason(response.finish_reason),\n      usage: {\n        promptTokens: response.meta.tokens.input_tokens,\n        completionTokens: response.meta.tokens.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: {\n          chat_history,\n          message,\n        },\n        rawSettings,\n      },\n      response: {\n        id: response.generation_id ?? undefined,\n      },\n      rawResponse: { headers: responseHeaders },\n      warnings: undefined,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const args = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n      },\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonStreamResponseHandler(\n        cohereChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { chat_history, message, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n\n    const generateId = this.config.generateId;\n    const toolCalls: Array<{\n      toolCallId: string;\n      toolName: string;\n    }> = [];\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof cohereChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n            const type = value.event_type;\n\n            switch (type) {\n              case 'text-generation': {\n                controller.enqueue({\n                  type: 'text-delta',\n                  textDelta: value.text,\n                });\n                return;\n              }\n\n              case 'tool-calls-chunk': {\n                if (value.tool_call_delta) {\n                  const { index } = value.tool_call_delta;\n\n                  if (toolCalls[index] === undefined) {\n                    const toolCallId = generateId();\n\n                    toolCalls[index] = {\n                      toolCallId,\n                      toolName: '',\n                    };\n                  }\n\n                  if (value.tool_call_delta.name) {\n                    toolCalls[index].toolName = value.tool_call_delta.name;\n\n                    controller.enqueue({\n                      type: 'tool-call-delta',\n                      toolCallType: 'function',\n                      toolCallId: toolCalls[index].toolCallId,\n                      toolName: toolCalls[index].toolName,\n                      argsTextDelta: '',\n                    });\n                  } else if (value.tool_call_delta.parameters) {\n                    controller.enqueue({\n                      type: 'tool-call-delta',\n                      toolCallType: 'function',\n                      toolCallId: toolCalls[index].toolCallId,\n                      toolName: toolCalls[index].toolName,\n                      argsTextDelta: value.tool_call_delta.parameters,\n                    });\n                  }\n                }\n                return;\n              }\n\n              case 'tool-calls-generation': {\n                for (let index = 0; index < value.tool_calls.length; index++) {\n                  const toolCall = value.tool_calls[index];\n\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallId: toolCalls[index].toolCallId,\n                    toolName: toolCalls[index].toolName,\n                    toolCallType: 'function',\n                    args: JSON.stringify(toolCall.parameters),\n                  });\n                }\n\n                return;\n              }\n\n              case 'stream-start': {\n                controller.enqueue({\n                  type: 'response-metadata',\n                  id: value.generation_id ?? undefined,\n                });\n\n                return;\n              }\n\n              case 'stream-end': {\n                finishReason = mapCohereFinishReason(value.finish_reason);\n                const tokens = value.response.meta.tokens;\n\n                usage = {\n                  promptTokens: tokens.input_tokens,\n                  completionTokens: tokens.output_tokens,\n                };\n              }\n\n              default: {\n                return;\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: {\n          chat_history,\n          message,\n        },\n        rawSettings,\n      },\n      rawResponse: { headers: responseHeaders },\n      warnings: [],\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereChatResponseSchema = z.object({\n  generation_id: z.string().nullish(),\n  text: z.string(),\n  tool_calls: z\n    .array(\n      z.object({\n        name: z.string(),\n        parameters: z.unknown({}),\n      }),\n    )\n    .nullish(),\n  finish_reason: z.string(),\n  meta: z.object({\n    tokens: z.object({\n      input_tokens: z.number(),\n      output_tokens: z.number(),\n    }),\n  }),\n});\n\n// limited version of the schema, focused on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereChatChunkSchema = z.discriminatedUnion('event_type', [\n  z.object({\n    event_type: z.literal('stream-start'),\n    generation_id: z.string().nullish(),\n  }),\n  z.object({\n    event_type: z.literal('search-queries-generation'),\n  }),\n  z.object({\n    event_type: z.literal('search-results'),\n  }),\n  z.object({\n    event_type: z.literal('text-generation'),\n    text: z.string(),\n  }),\n  z.object({\n    event_type: z.literal('citation-generation'),\n  }),\n  z.object({\n    event_type: z.literal('tool-calls-generation'),\n    tool_calls: z.array(\n      z.object({\n        name: z.string(),\n        parameters: z.unknown({}),\n      }),\n    ),\n  }),\n  z.object({\n    event_type: z.literal('tool-calls-chunk'),\n    text: z.string().optional(),\n    tool_call_delta: z\n      .object({\n        index: z.number(),\n        name: z.string().optional(),\n        parameters: z.string().optional(),\n      })\n      .optional(),\n  }),\n  z.object({\n    event_type: z.literal('stream-end'),\n    finish_reason: z.string(),\n    response: z.object({\n      meta: z.object({\n        tokens: z.object({\n          input_tokens: z.number(),\n          output_tokens: z.number(),\n        }),\n      }),\n    }),\n  }),\n]);\n\n// For reference: https://docs.cohere.com/docs/parameter-types-in-tool-use\n\nfunction prepareToolsAndToolChoice(\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  },\n) {\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  if (tools == null) {\n    return { tools: undefined };\n  }\n\n  const mappedTools = tools.map(tool => {\n    const { properties, required } = tool.parameters;\n\n    const parameterDefinitions: any = {};\n\n    if (properties) {\n      for (const [key, value] of Object.entries(properties)) {\n        if (typeof value === 'object' && value !== null) {\n          const { type: JSONType, description } = value;\n\n          let type: 'str' | 'float' | 'int' | 'bool';\n\n          if (typeof JSONType === 'string') {\n            switch (JSONType) {\n              case 'string':\n                type = 'str';\n                break;\n              case 'number':\n                type = 'float';\n                break;\n              case 'integer':\n                type = 'int';\n                break;\n              case 'boolean':\n                type = 'bool';\n                break;\n              default:\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'tool call parameter of non-primitive type',\n                });\n            }\n          } else {\n            throw new UnsupportedFunctionalityError({\n              functionality: 'tool call parameter of non-primitive type',\n            });\n          }\n\n          parameterDefinitions[key] = {\n            required: required ? required.includes(key) : false,\n            type,\n            description,\n          };\n        }\n      }\n    }\n\n    return {\n      name: tool.name,\n      description: tool.description,\n      parameterDefinitions,\n    };\n  });\n\n  const toolChoice = mode.toolChoice;\n\n  if (toolChoice == null) {\n    return { tools: mappedTools, force_single_step: false };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return { tools: mappedTools, force_single_step: false };\n    case 'required':\n      return { tools: mappedTools, force_single_step: true };\n\n    // cohere does not support 'none' tool choice, so we remove the tools:\n    case 'none':\n      return { tools: undefined, force_single_step: false };\n\n    // cohere does not support tool mode directly,\n    // so we filter the tools and force the tool choice through 'any'\n    case 'tool':\n      return {\n        tools: mappedTools.filter(tool => tool.name === toolChoice.toolName),\n        force_single_step: true,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\nconst cohereErrorDataSchema = z.object({\n  message: z.string(),\n});\n\nexport type CohereErrorData = z.infer<typeof cohereErrorDataSchema>;\n\nexport const cohereFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: cohereErrorDataSchema,\n  errorToMessage: data => data.message,\n});\n","import {\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { CohereChatPrompt } from './cohere-chat-prompt';\n\nexport function convertToCohereChatPrompt(\n  prompt: LanguageModelV1Prompt,\n): CohereChatPrompt {\n  const messages: CohereChatPrompt = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'SYSTEM', message: content });\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'USER',\n          message: content\n            .map(part => {\n              switch (part.type) {\n                case 'text': {\n                  return part.text;\n                }\n                case 'image': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'image-part',\n                  });\n                }\n              }\n            })\n            .join(''),\n        });\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          name: string;\n          parameters: object;\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                name: part.toolName,\n                parameters: part.args as object,\n              });\n              break;\n            }\n            default: {\n              const _exhaustiveCheck: never = part;\n              throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n\n        messages.push({\n          role: 'CHATBOT',\n          message: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n        });\n\n        break;\n      }\n      case 'tool': {\n        messages.push({\n          role: 'TOOL',\n          tool_results: content.map(toolResult => ({\n            call: {\n              name: toolResult.toolName,\n\n              /* \n              Note: Currently the tool_results field requires we pass the parameters of the tool results again. It it is blank for two reasons:\n\n              1. The parameters are already present in chat_history as a tool message\n              2. The tool core message of the ai sdk does not include parameters\n              \n              It is possible to traverse through the chat history and get the parameters by id but it's currently empty since there wasn't any degradation in the output when left blank.\n              */\n              parameters: {},\n            },\n            outputs: [toolResult.result as object],\n          })),\n        });\n\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return messages;\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapCohereFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'COMPLETE':\n    case 'STOP_SEQUENCE':\n      return 'stop';\n\n    case 'MAX_TOKENS':\n      return 'length';\n\n    case 'ERROR':\n    case 'ERROR_LIMIT':\n      return 'error';\n\n    case 'ERROR_TOXIC':\n      return 'content-filter';\n\n    case 'USER_CANCEL':\n      return 'other';\n\n    default:\n      return 'unknown';\n  }\n}\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  FetchFunction,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport {\n  CohereEmbeddingModelId,\n  CohereEmbeddingSettings,\n} from './cohere-embedding-settings';\nimport { cohereFailedResponseHandler } from './cohere-error';\n\ntype CohereEmbeddingConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class CohereEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: CohereEmbeddingModelId;\n\n  readonly maxEmbeddingsPerCall = 96;\n  readonly supportsParallelCalls = true;\n\n  private readonly config: CohereEmbeddingConfig;\n  private readonly settings: CohereEmbeddingSettings;\n\n  constructor(\n    modelId: CohereEmbeddingModelId,\n    settings: CohereEmbeddingSettings,\n    config: CohereEmbeddingConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/embed`,\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        texts: values,\n        input_type: this.settings.inputType ?? 'search_query',\n        truncate: this.settings.truncate,\n      },\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.embeddings,\n      usage: { tokens: response.meta.billed_units.input_tokens },\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereTextEmbeddingResponseSchema = z.object({\n  embeddings: z.array(z.array(z.number())),\n  meta: z.object({\n    billed_units: z.object({\n      input_tokens: z.number(),\n    }),\n  }),\n});\n"],"mappings":"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","names":["UnsupportedFunctionalityError","z","UnsupportedFunctionalityError","generateId","z","type","combineHeaders","createJsonResponseHandler","postJsonToApi","z","postJsonToApi","combineHeaders","createJsonResponseHandler","z","_a"]}